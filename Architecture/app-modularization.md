# 모듈화의 이점

- 재사용성
- 엄격한 공개 상태 제어
- 확장성 (결합도 ⬇️, 응집도 ⬆️)
- 소유권 (명확한 책임)
- 캡슐화
- 테스트 가능성
- 빌드 시간 감소

# 모듈화에서 중요한 것

**모든 프로젝트에 적합한 단 하나의 모듈화 전략은 없다.** 회사의 비즈니스, 고객의 요구사항 및 기타 환경에 알맞게 전략을 세워야 한다. 

일반적으로 모듈 구성의 품질을 측정하는 지표로 다음 3가지 항목이 있다. 

### 결합도 (Coupling) ⬇️

- 모듈이 최대한 **독립적**이어야 한다.
- 한 모듈의 변경사항이 다른 모듈에 미치는 영향이 없거나 최소여야 한다.
- 한 모듈은 다른 모듈의 내부 작동을 알 수 없어야 한다.

### 응집도 (Cohesion) ⬆️

- 모듈이 **시스템 역할을 하는 코드 모음**으로 구성되어야 한다.
- **모듈이 맡은 역할이 명확히 규정**되어 있고, 특정 도메인 지식의 범위를 벗어나지 않아야 한다.
  - ex) 도서 기능, 결제 기능 → 별도의 모듈로 분리 
        
### 세분성 (Granularity) ⬆️

- 코드 베이스가 모듈로 구성되는 정도
- 모듈의 개수 / 코드 베이스 크기 (구체적인 단위가 아닌 개념으로 사용)
    
# 모듈화 기준

## 계층별로 모듈화

<img width="400" src="https://github.com/leeeha/Android-TIL/assets/68090939/32b4d768-8929-4819-af05-41f9b0270ecf"/>

- **UI Layer** : UI (View, Composable)와 State holder (ViewModel) 등이 포함된다.
- **Domain Layer** : Use case가 포함되어 복잡한 비즈니스의 캡슐화를 담당한다.
- **Data Layer** : Repository, DataSource 등이 포함되며, 앱에서 처리하는 다양한 유형의 데이터를 다룬다.
- **응집도 ⬆️** : 아키텍처 레이어는 본질적으로 응집력이 있는 경향이 있다. 각 계층은 모두 잘 정의된 책임을 갖고 있으며, 하나의 시스템으로 작동한다.
- **결합도** **⬆️** : ui 모듈의 변경사항은 ui 모듈 자체로 제한된다. 그러나 domain 모듈이 바뀌면 ui 모듈이 다시 컴파일 될 수 있다. 만약 data 모듈이 바뀌면 모든 모듈이 다시 컴파일 될 수 있다. 작은 코드 기반에서는 잘 작동할 수 있지만, **모듈이 점점 커지면 코드의 세분성을 높이는 방법을 고려할 필요가 있다.** 모듈이 너무 커지면 또 다른 모놀리식 구조가 될 수 있기 때문이다.

## 기능별로 모듈화

책과 관련된 앱을 만든다고 생각해보자. 이 앱은 책(:books), 저자(:authors),리뷰(:reviews) 기능들로 구성되어 있으며, 기능별로 모듈을 구성한다면 다음 그림과 같을 것이다. 

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/93b65469-be94-4f8c-b10c-4be7b18c449f"/>

책 화면에서 저자와 리뷰 정보를 표시해야 한다면 어떻게 될까? 

book 모듈에서 author, review 모듈에 이미 구현된 기능을 다시 구현해야 하므로 코드의 중복성이 생긴다.

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/c7000326-98cc-4671-a379-cf865718cdd7"/>

코드의 재사용을 위해 기능 모듈이 서로 의존하게 만들 수 있지만, 이는 결합도가 너무 높아진다는 단점이 있다. 그리고 기능을 단독으로 개발하는 것도 어려워진다. 

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/2d165f9f-a71f-4a1b-af22-664db00541fc"/>

- **응집도** ⬆️ : 각 기능 모듈에는 고유한 책임이 있고, 하나의 시스템처럼 작동하며, 독립적으로 개발될 수 있다.
- **결합도** ⬆️ : 코드의 재사용을 위해 다른 모듈을 참조하게 되면 결합도가 매우 높아진다.

## 계층 + 기능별로 모듈화

계층별로 나눌 때는 코드의 응집도가 높다는 장점이 있지만, 결합도가 높고 모듈의 세분화 정도가 떨어지는 단점이 있다. 

기능별로 나눌 때는 세분화가 잘되는 장점이 있지만, 결합도가 높아지기 쉽다는 단점이 있다. 

두 솔루션을 결합하여 서로의 단점을 보완해보도록 하자. 다음 그림은 그 예를 나타낸다.

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/f2a30918-a551-451e-98dc-cf9ce928d36d"/>

참고: 이 다이어그램은 상위 계층에서 하위 계층으로만 의존한다는 전제 조건을 갖는다. (수평적으로도 의존하면 안 된다.) 

두 솔루션을 합치면 다음과 같은 장점을 얻을 수 있다. 

- 각 모듈은 고도로 전문적이며, 독립적이기 때문에 코드 **응집도**를 높일 수 있다.
- 각 모듈은 **느슨하게 결합**되므로 추후에 시스템을 손쉽게 수정할 수 있다.
- 모듈이 **세분화**되어 있으므로 쉽게 재사용할 수 있다.

# 모듈 타입

권장 앱 아키텍처를 따르면서 앱에 도입할 수 있는 일반적인 모듈 타입에 대해 알아보자. 

## data

- Repository, DataSource, Model 포함
- 특정 도메인의 모든 **데이터, 비즈니스 로직 캡슐화**
- 공개 API 저장소 → 외부에 노출 O
- 모든 구현의 세부 정보, DataSource → 외부에 노출 X (같은 모듈의 저장소에서만 접근 가능)

<img width="800" src="https://github.com/leeeha/Android-TIL/assets/68090939/f05c8979-9863-4a02-9716-5906de14bf54"/>

## feature

- 화면 또는 밀접하게 연관된 **일련의 화면에 해당하는 독립적인 앱 기능**을 의미
  - ex) 바텀 네비게이션의 각 탭을 feature 모듈로 분리 
- 로직과 상태를 처리하는 UI, ViewModel과 연결되는 경우가 많음.
- 데이터 모듈에 종속

<img width="800" src="https://github.com/leeeha/Android-TIL/assets/68090939/b8b27418-0fe4-4fe7-a9ab-39a3757c51b5"/>

## app

- **어플리케이션의 진입점**
- feature 모듈에 종속
- 루트 네비게이션 제공
- build variant 사용하여 단일 앱 모듈을 다양한 바이너리로 컴파일 가능

<img width="800" src="https://github.com/leeeha/Android-TIL/assets/68090939/91d80437-6ca7-4d53-920b-ff4d738ebb54"/>

- 앱이 자동차, 웨어러블, TV와 같이 여러 디바이스 타입을 타겟팅 하는 경우 기기별로 앱 모듈을 정의함.
- 플랫폼별로 종속 항목을 구분하는 데 용이

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/10b3bbf1-046e-4b22-9162-ba3989bac7a7"/>

## common (core)

- **다른 모듈에서 자주 사용하는 코드를 포함하는 모듈**
- 중복되는 코드를 줄이는 역할
- 앱 아키텍처의 특정 레이어를 나타내지 않음.
- **ui 모듈**: 앱에서 커스텀 UI 컴포넌트를 사용하거나 정교한 브랜딩을 사용하는 경우, 모든 기능을 재사용 할 수 있도록 위젯 컬렉션을 하나의 모듈로 캡슐화 하는 게 좋다. (서로 다른 기능에서 일관된 UI를 만들 수 있고, 리브랜딩이 발생할 때 빠르게 변경사항 반영 가능)
- **애널리틱스 모듈**: 주로 애널리틱스는 소프트웨어 아키텍처에 대한 고려 없이 비즈니스 요구사항에 따라 정해진다. 즉, 애널리틱스 트래커를 서로 관련 없는 여러 컴포넌트에서 사용하는 경우가 많으므로, 전용 애널리틱스 모듈을 만들어 사용하는 게 좋다.
- **네트워크 모듈**: 많은 모듈에 네트워크 연결이 필요하다면 http 클라이언트를 제공하는 전용 모듈을 사용하는 게 좋다. 클라이언트에게 맞춤 구성이 필요할 때 특히 유용하다.
- **유틸리티 모듈**: 어플리케이션 전체에서 재사용 되는 작은 코드 ex) 테스트 유틸리티, 화폐 포맷 지정 함수, 이메일 검사기, 맞춤 연산자 등

## test

- 테스트용으로만 사용되는 모듈
- 테스트 실행에만 필요하고 어플리케이션 런타임에는 필요하지 않은 테스트 코드, 테스트 리소스, 테스트 종속 항목 포함
- 기본 어플리케이션과 테스트용 코드가 분리되어 생성되므로 모듈 코드를 더 쉽게 관리하고 유지할 수 있음.

<img width="800" src="https://github.com/leeeha/Android-TIL/assets/68090939/b5bccdf9-42cd-43a4-b97a-7c8572c648ee"/>

# 모듈 간 통신

모듈은 완전히 분리되는 경우는 거의 없으며, 다른 모듈에 의존하여 서로 통신하는 경우가 많다. 모듈이 함께 작동하고 정보를 자주 교환할 때도 **결합도를 낮게 유지하는 것이 중요**하다. 

두 모듈 간의 직접적인 통신은 아키텍처 제약 조건과 마찬가지로 바람직하지 않다. 두 모듈이 **직접 통신하면 순환 참조 같은 문제가 발생**할 수 있다. 

이런 문제를 극복하기 위해 두 개의 모듈을 중재하는 모듈을 둘 수 있다. **중재 모듈**은 두 모듈의 메시지를 수신 대기하고 필요에 따라 메시지를 전달할 수 있다. 

ex) Navigation Graph를 소유하고 있는 앱 모듈 

<img width="800" src="https://github.com/leeeha/Android-TIL/assets/68090939/5cd19444-3f51-421d-b81e-4e169380e75d"/>

아래 그림에서 두 feature 모듈은 동일한 data 모듈에 종속된다. 이렇게 하면 중재 모듈이 전달해야 하는 데이터양을 최소화 하고 모듈 간의 결합도를 낮게 유지할 수 있다. 모듈은 객체를 전달하는 대신에 기본 id를 교환하고 공유 data 모듈에서 리소스를 로드해야 한다. 

<img width="400" src="https://github.com/leeeha/Android-TIL/assets/68090939/dab719a3-c65d-4caf-9c79-6844325bdd95"/>

# 의존성 역전

**: 추상화가 구체적인 구현으로부터 분리되도록 코드를 구성하는 것** 

- **추상화**
    - 어플리케이션의 컴포넌트 또는 모듈이 서로 상호 작용하는 방식을 정의하는 계약
    - 추상화 모듈은 **시스템의 API를 정의**하고 인터페이스와 모델을 포함한다.
- **구체적인 구현**
    - 추상화 모듈에 종속되며 **추상화의 동작을 구현**하는 모듈

추상화 모듈에 정의된 동작을 사용하는 모듈은 **특정 구현이 아닌 추상화 자체에만 종속**되어야 한다.

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/5af6e12b-433b-4ebc-8856-86b705e76abd"/>

→ 상위 모듈이 하위 모듈에 직접 종속되는 대신에 **상위 모듈과 구현 모듈이 모두 추상화 모듈에 종속**된다. (의존성 역전)

예를 들어, 데이터베이스가 필요한 feature 모듈이 있다고 가정해보자. 

이때 데이터베이스는 로컬 Room 데이터베이스, 원격 Firestore 인스턴스 등 **구현 방식이 무엇이어도 상관없다.** 데이터베이스가 어플리케이션의 데이터를 저장하고 읽을 수만 있으면 된다. 

이를 위해 **feature 모듈은 특정 데이터베이스 구현이 아닌 추상화 모듈에 종속**된다. 이 추상화는 앱의 데이터베이스 API를 정의한다. 즉, 데이터베이스와 상호작용 하는 방법에 관한 규칙을 설정한다. 이로써 feature 모듈은 데이터베이스의 세부적인 구현 정보를 알 필요 없이 어떤 데이터베이스도 사용할 수 있다. 

구체적인 구현 모듈은 추상화 모듈에 정의된 API의 실제 구현을 제공한다. 이를 위해 **구현 모듈도 추상화 모듈에 종속**된다. 

## 의존성 주입

feature 모듈과 구현 모듈을 어떻게 연결해야 할까? 바로 **의존성 주입**을 활용하면 된다! 

feature 모듈은 필요한 데이터베이스 인스턴스를 직접 만들지 않는다. 대신에 **어떤 의존성이 필요한지 지정**한다. 이러한 종속 항목은 외부에서 (주로 앱 모듈에서) 제공된다. 

```kotlin
releaseImplementation(project(":database:impl:firestore"))
debugImplementation(project(":database:impl:room"))
androidTestImplementation(project(":database:impl:mock"))
```

## 장점 

추상화와 구체적인 구현을 분리하는 ‘의존성 역전’에는 여러가지 이점이 있다. 

- **상호 교환성** : 시스템의 API와 구현 모듈이 명확히 분리되면, 동일한 API의 여러 구현을 개발한 다음 **API를 사용하는 코드를 변경하지 않고도 구현을 서로 전환할 수 있다.** 이는 맥락에 따라 서로 다른 기능이나 동작을 제공하려는 경우에 특히 유용하다. (ex. 테스트용 모의 구현과 프로덕션용 실제 구현)
- **낮은 결합도** : **추상화를 사용하는 모듈이 특정 기술에 종속되지 않는다.** 나중에 데이터베이스를 Room에서 Firestore로 변경해도 작업을 담당하는 특정 모듈(구현 모듈)만 변경하면 되고, 데이터베이스의 **API를 사용하는 다른 모듈은 영향을 받지 않는다.**
- **테스트 가능성** : 테스트가 크게 용이해진다. 테스트 케이스를 API에 대해 작성할 수 있고, 여러 구현을 사용하여 모의 구현을 비롯한 다양한 시나리오와 특수한 케이스를 테스트 할 수 있다.
- **빌드 성능 개선** : **구현 모듈이 변경되어도 빌드 시스템이 API 모듈에 종속된 모듈을 재컴파일 하지 않는다.** 따라서 빌드 시간이 단축되고, 빌드 시간이 중요한 대규모 프로젝트의 생산성이 향상된다.

## 구현 방법

### 추상화 모듈 생성 

- 기능의 동작을 정의하는 API (인터페이스, 모델 포함)
    
### 구현 모듈 생성

- 추상화 모듈에 종속
- 추상화의 동작 구현
  
<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/9b391fa7-eb43-45a0-98e3-8162155407f8"/>

### 상위 모듈을 추상화 모듈에 종속

- 모듈이 특정 구현에 직접 종속되지 않고, 추상화 모듈에 종속되게 함.
- 상위 모듈은 구현의 세부정보를 알 필요 없이 API(계약)만 있으면 됨.
  
<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/70d578b1-b752-41f1-bcae-ac871dcaeaa9"/>
    
### 구현 모듈 제공

- 종속 항목의 실제 구현 제공
- 구체적인 구현은 프로젝트 설정에 따라 다르지만, 일반적으로 앱 모듈에 구현하는 게 좋음.
- 의존성 주입을 통해 구체적인 구현을 feature 모듈에 제공
  
<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/5ff65999-500a-401d-bd57-cc9c8b97b33f"/>

# General best practices

## 일관된 configuration 유지

- 모든 모듈에는 **configuration 오버헤드**가 발생함.
- 모듈 수가 특정 기준점에 도달하면 일관된 configuration 관리가 어려워짐.
- 예를 들어 모듈에서 동일한 버전의 디펜던시를 사용하는 게 중요한데, 단지 이 버전을 올리기 위해 여러 개의 모듈을 리빌드 해야 하는 경우 비효율적이다.
- 따라서, 버전 카탈로그와 convention plugin 같은 Gradle 도구들을 사용하여 **configuration을 중앙 집중화** 하는 게 좋다.
- **버전 카탈로그**
  - Sync 하는 동안 Gradle에서 생성된 디펜던시의 type-safe한 목록 제공
  - 모든 디펜던시를 선언할 수 있는 중앙 위치
  - 프로젝트의 모든 모듈에서 사용 가능
- **convention plugin**
  - 모듈 간의 빌드 로직 공유를 위해 사용 

## 노출 최소화

- **모듈의 공개 인터페이스를 최소화 하고, 필수적인 부분만 노출해야 한다.**
- 구현의 세부정보가 외부에 유출되면 안 된다.
- 모든 범위를 가능한 최소 수준으로 지정한다.
- Kotlin의 `private`, `internal` 키워드로 **모듈을 비공개로 설정**한다.
- 모듈에서 디펜던시를 선언할 때는 `api` 보다 `implementation` 을 사용하는 게 좋다. (리빌드 해야 하는 모듈 수가 줄어들어 빌드 시간 개선 가능)

## Kotlin, Java 모듈 선호

안드로이드 스튜디오에서 지원하는 세 가지 필수 모듈 

- **앱 모듈**
    - 어플리케이션의 진입점
    - 소스 코드, 리소스, 애셋, 매니페스트 파일 포함
    - 앱 모듈의 추출: AAB 또는 APK
- **라이브러리 모듈**
    - 앱 모듈과 동일한 콘텐츠 포함
    - 다른 안드로이드 모듈에 종속 항목으로 사용됨.
    - 여러 앱 모듈 간에 동일한 로직과 리소스를 캡슐화하여 재사용 
    - 라이브러리 모듈의 추출: 앱 모듈과 구조적으로 동일한 AAR (나중에 다른 모듈에서 종속 항목으로 사용할 수 있는 AAR로 컴파일 됨.)
- **코틀린, 자바 모듈**
    - 안드로이드 리소스, 애셋, 매니페스트 파일 포함 X
    - 안드로이드 프레임워크에 의존하지 않고, 순수 코틀린 또는 자바 코드로 이루어진 모듈

안드로이드 모듈에는 오버헤드가 발생하므로 가능하면 **자바 또는 코틀린 모듈을 사용**하는 게 좋다. 

# 참고자료

[By layer or feature? Why not both?! Guide to Android app modularization](https://youtu.be/16SwTvzDO0A?feature=shared)

[Guide to Android app modularization  |  Android Developers](https://developer.android.com/topic/modularization)

[안드로이드 앱 모듈화 가이드 | 찰스의 안드로이드](https://www.charlezz.com/?p=46545)