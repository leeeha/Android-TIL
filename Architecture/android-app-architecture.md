# 아키텍처의 이점

- 앱의 전반적인 유지관리, 품질, 견고성 개선
- 앱의 확장성 증가. 코드 충돌이 최소화 되어 더 많은 인력이 동일한 코드베이스에 기여할 수 있다.
- 온보딩에 도움이 된다. 아키텍처는 프로젝트에 일관성을 부여하므로 새로운 팀원이 빠르게 업무를 시작하고 보다 짧은 시간에 효율을 높일 수 있다.
- 테스트하기가 더 쉽다. 좋은 아키텍처는 테스트하기 더 쉬운 간단한 타입을 사용하도록 지원한다.
- 잘 정의된 프로세스를 통해 체계적으로 버그를 조사할 수 있다.

# 모바일 앱 사용자 환경

일반적인 안드로이드 앱에는 **액티비티, 프래그먼트, 서비스, 콘텐츠 프로바이더, 브로드캐스트 리시버**를 비롯하여 여러 앱 컴포넌트가 포함된다. 

개발자는 **앱 매니페스트 파일에 이런 앱 컴포넌트 대부분을 선언**하며, 안드로이드 OS는 이 파일을 사용해 기기의 전반적인 사용자 경험에 앱을 통합하는 방법을 결정한다. 

일반적인 안드로이드 앱은 여러 컴포넌트를 포함할 수 있고, 사용자는 짧은 시간 내에 여러 앱과 상호작용 할 때도 많다는 걸 고려하면, **앱은 사용자 중심의 다양한 워크플로우나 작업에 맞게 조정**될 수 있어야 한다. 

또한 **휴대기기는 리소스가 제한**되어 있으므로, **운영체제에서 새로운 앱을 위한 공간 확보를 위해 언제든지 일부 앱 프로세스를 종료**할 수 있다. 

이런 환경 조건을 고려할 때, **앱 컴포넌트는 개별적이고 비순차적으로 실행될 수 있으며, 운영체제나 사용자가 언제든지 앱 구성요소를 소멸**시킬 수 있다. 이런 이벤트는 직접 제어할 수 없기 때문에, **앱 컴포넌트에 어플리케이션 데이터나 상태를 저장해서는 안 되며 앱 컴포넌트가 서로 종속되면 안 된다.** 

그렇다면, 앱을 어떻게 설계해야 할까? 

안드로이드 앱은 크기가 점점 커지기 때문에 앱의 확장성과 견고함을 높이고, 테스트를 더 쉽게 할 수 있도록 아키텍처를 정의하는 것이 중요하다.

앱 아키텍처는 앱의 각 부분에 필요한 기능 간의 경계를 정의한다. 위에 언급된 요구사항을 충족하려면, 몇 가지 특정 원칙을 준수하도록 앱 아키텍처를 설계해야 한다.

# 일반 아키텍처 원칙

## 관심사 분리

가장 중요한 원칙은 **관심사의 분리**이다. 

- **액티비티, 프래그먼트에 모든 코드를 작성하는 실수**는 흔히 발생한다. 이런 **UI 기반 클래스는 UI 및 운영체제 상호작용을 처리하는 로직만 포함**해야 한다.
- UI 기반의 클래스를 **최대한 가볍게 유지**하여 컴포넌트 생명 주기와 관련된 많은 문제를 피하고, 해당 클래스의 테스트 가능성도 개선할 수 있다.
- 운영체제는 사용자 상호작용을 기반으로 또는 메모리 부족과 같은 시스템 조건으로 인해 **언제든지 클래스를 소멸**시킬 수 있다. 이 클래스들은 안드로이드 OS와 앱 사이의 계약을 나타내도록 이어주는 클래스일 뿐이지, 데이터의 소유자가 되면 안 된다.
- 만족스러운 사용자 환경과 더욱 수월한 앱 관리 환경을 제공하려면, 이런 **클래스에 대한 의존성을 최소화** 하는 것이 좋다.

## 데이터 모델에서 UI 도출

가급적 **지속 가능한 모델로부터 UI를 도출**해야 한다.

- **데이터 모델은 앱의 데이터를 나타내며, 앱의 UI 요소 및 기타 구성요소로부터 독립되어 있다.** 즉, UI 및 앱 컴포넌트의 생명주기와 무관하다. 하지만, OS가 메모리에서 앱의 프로세스를 삭제하면, 데이터 모델도 같이 삭제된다.
- 지속 가능한 모델이 이상적인 이유
    - **안드로이드 OS에서 리소스 확보를 위해 앱을 제거해도 사용자 데이터가 삭제되지 않는다.**
    - **네트워크 연결이 취약하거나 연결되어 있지 않아도 앱이 계속 작동한다.**
- 데이터 모델 클래스를 기반으로 앱 아키텍처를 구축하면, **앱의 테스트 가능성과 견고성**이 높아진다.

## 단일 소스 저장소 (Single Source Of Truth, SSOT)

- **SSOT는 데이터의 소유자**
- **SSOT만 데이터를 수정하거나 변경할 수 있다.**
    - 불변 타입으로 데이터 노출
    - 다른 타입이 호출한 이벤트 수신
    - 함수를 노출하여 데이터 수정
- SSOT 패턴의 이점
    - **특정 타입 데이터의 모든 변경사항을 한곳으로 일원화**
    - **외부에서 조작할 수 없도록 데이터 보호**
    - **데이터 변경사항을 더 쉽게 추적 가능 → 디버깅에 용이**

## 단방향 데이터 흐름 (Unidirectional Data Flow, UDF)

UDF에서 `상태`는 한 방향으로만 흐르며, 데이터를 수정하는 `이벤트`는 반대 방향으로 흐른다.

- 상태 또는 데이터는 상위 레벨에서 하위 레벨로 흐른다. (DataSource → UI)
- 이벤트는 하위 레벨에서 트리거되어 상응하는 데이터 유형의 SSOT에 도달한다. (UI → SSOT)

<img width="600" src="https://github.com/user-attachments/assets/11c86f31-fa51-43bb-b2bd-fc223be86eae"/>

1. ViewModel이 UI에 사용될 상태를 보유하고 노출한다. (UI 상태는 ViewModel에 의해 변환된 어플리케이션 데이터를 의미함)
2. UI가 ViewModel에 사용자 이벤트를 알린다. 
3. ViewModel이 사용자 작업을 처리하고, 상태를 업데이트한다. 
4. 업데이트 된 상태가 렌더링 할 UI에 다시 제공된다. 
5. 상태 변경을 일으키는 모든 이벤트에 대해 위의 작업들이 반복된다.

```kotlin
data class NewsUiState(
    val isSignedIn: Boolean = false,
    val isPremium: Boolean = false,
    val newsItems: List<NewsItemUiState> = listOf(),
    val userMessages: List<Message> = listOf()
)

data class NewsItemUiState(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    ...
)
```

# 권장 앱 아키텍처

<img width="600" src="https://github.com/user-attachments/assets/a2f29367-f3d7-48ac-b2e1-ec30f7b1af07"/>

- UI 레이어: 화면에 어플리케이션 데이터를 표시함.
- 데이터 레이어: 앱의 비즈니스 로직 포함, 어플리케이션 데이터 노출
- 도메인 레이어: UI, 데이터 레이어 간의 상호작용 간소화 및 재사용을 위해 추가 가능

## UI 레이어

**화면에 어플리케이션 데이터 표시** 

사용자 상호작용 (버튼 클릭) 또는 외부 입력 (네트워크 응답)으로 인해 데이터가 변할 때마다 변경사항을 반영하도록 UI가 갱신되어야 한다.

- `UI element` : 화면에 데이터를 렌더링하는 UI 요소 (View, Compose)
- `State holder` : 데이터를 보유하고 이를 UI에 노출하며 로직을 처리함. (ViewModel)

<img width="600" src="https://github.com/user-attachments/assets/e349c266-88e4-495b-a0a9-d2e8b4ab586c"/>

## 데이터 레이어

**앱의 비즈니스 로직 포함** 

비즈니스 로직: 앱에 가치를 부여하며, 앱의 데이터 생성, 저장, 변경 방식을 결정하는 규칙

- `Repository` : 앱의 나머지 부분에 데이터 소스의 추상화를 노출함.
- `DataSource` : 파일, 네트워크 소스, 로컬 DB 같은 하나의 데이터 소스 (어플리케이션과 시스템 간의 가교 역할)

<img width="600" src="https://github.com/user-attachments/assets/07ad16fd-3767-4e9c-8609-f8775663c4e3"/>

## 도메인 레이어

**UI 레이어와 데이터 레이어 사이에 있는 선택적 레이어**

- 복잡한 비즈니스 로직이나 여러 ViewModel에서 재사용 되는 간단한 비즈니스 로직의 캡슐화 담당
- 복잡성을 처리하거나 재사용성을 선호하는 등 필요한 경우에만 선택적으로 사용
- 도메인 레이어의 클래스는 일반적으로 `UseCase`라고 하는데, 각 `UseCase`는 하나의 기능만 담당해야 한다.

<img width="600" src="https://github.com/user-attachments/assets/4665ca28-c778-4234-99a7-834bd2791c26"/>

# 컴포넌트 간 의존성 관리

앱의 클래스는 올바른 작동을 위해 다른 클래스에 종속된다.

**의존성 주입을 사용하면 클래스가 자신의 의존성을 직접 구현할 필요 없이 외부에서 주입 받을 수 있다. 대신 런타임에 다른 클래스가 이 의존성을 제공해야 한다.** 

코드의 확장성과 테스트 가능성을 높이기 위해 의존성 주입 패턴을 따르고, 안드로이드 앱에서 Hilt 라이브러리를 사용하는 게 좋다. 

**Hilt는 프로젝트에서 수동으로 의존성 주입 시 발생하는 상용구 코드를 줄여주는 Android용 의존성 주입 라이브러리다.** 수동으로 의존성을 주입하려면, 모든 클래스와 의존성을 수동으로 구성하고 컨테이너를 사용하여 의존성을 재사용 및 관리해야 한다.

**Hilt는 프로젝트의 모든 Android 클래스에 컨테이너를 제공하고 수명 주기를 자동으로 관리함으로써 애플리케이션에서 DI를 사용하는 표준 방법을 제공한다.** Hilt는 Dagger가 제공하는 컴파일 타임의 정확성, 런타임 성능, 확장성 및 [Android 스튜디오 지원](https://medium.com/androiddevelopers/dagger-navigation-support-in-android-studio-49aa5d149ec9)의 이점을 누리기 위해, 인기 있는 DI 라이브러리인 [Dagger](https://developer.android.com/training/dependency-injection/dagger-basics?hl=ko)를 기반으로 빌드되었다.

# 참고자료

https://developer.android.com/topic/architecture

