# Blocking 

<img width="500" src="https://github.com/user-attachments/assets/4db85220-ad34-4b72-8eda-2c5a84860947"/>

**블로킹이란 호출된 함수가 자신의 할일을 모두 마칠 때까지 호출한 함수에게 제어권을 주지 않고 대기하게 만드는 것이다.**

blocking이란 작업의 멈춤, 대기(wait)를 의미하는 단어다. 어떤 상황에서 누가 blocking 된다는 걸까?

블로킹 방식으로 A 함수가 B 함수를 호출했다고 가정해보자.

- A 함수는 B 함수를 호출하면서 제어권을 넘겨준다. 
- B 함수는 제어권을 넘겨 받고, 자신의 작업이 완료될 때까지 제어권을 돌려주지 않는다.
- A 함수는 B 함수가 제어권을 돌려줄 때까지 다른 작업을 수행하지 못하고, block 상태가 된다.
- B 함수의 작업이 완료되면 제어권을 A 함수에게 리턴한다. 
- 제어권을 다시 돌려받은 A 함수는 그 다음 작업을 수행한다. 

위의 그림에서 프로세스는 시스템 콜을 통해 커널 모드로 전환하여 I/O 작업을 요청하고, I/O 장치에서 해당 작업을 완료하여 결과를 반환할 때까지 해당 프로세스는 블로킹 된다. 

# Non-Blocking

<img width="500" src="https://github.com/user-attachments/assets/437ea5fe-68db-43b1-999e-36f2410b3bf9"/>

**논블로킹이란 호출된 함수의 작업 완료 여부와 상관없이 호출한 함수에게 제어권을 바로 넘겨줘서, 호출한 함수가 바로 다른 작업을 수행할 수 있는 것이다.** 

논블로킹 방식으로 A 함수에서 B 함수를 호출했다고 가정해보자. 

- A 함수는 B 함수를 호출하면서 제어권을 넘겨준다. 
- B 함수는 자신의 작업 완료 여부와 상관없이 제어권을 곧장 A에게 다시 넘긴다. 
- A 함수는 바로 제어권을 돌려 받아서 다른 작업을 수행할 수 있다.
- B 함수의 작업이 완료되면, 그 결과를 A 함수에게 통지한다. 

위의 그림에서 프로세스는 시스템 콜을 통해 커널 모드로 전환하여 I/O 작업을 요청하고, 곧바로 제어권을 돌려 받아서 I/O 작업 완료 여부와 상관없이 다른 작업을 수행할 수 있다.

# Synchronous

<img width="300" src="https://github.com/user-attachments/assets/91587703-7a54-4ea1-b9c7-5a4b467a5817"/>

**동기식 모델은 호출된 함수의 수행 결과 및 종료를, 호출한 함수에서 처리하는 것이다.** 

>Synchronous = Sync(함께) + Chrono(시간)<br>
>시간을 함께 맞춘다는 의미 

누가 어떤 시간을 맞춘다는 것일까? 

동기식 모델에서 A 함수가 B 함수를 호출하는 상황을 가정해보자.

- A 함수는 B 함수를 호출하고, B 함수의 수행 결과 및 종료를 처리한다. 
- B 함수가 완료될 때까지 대기하다가 처리할 수도 있고 (블로킹 동기)
- B 함수가 완료될 때까지 다른 작업을 수행하면서, B 작업의 완료 여부를 계속 체크하다가 처리할 수도 있다. (논블로킹 동기)

요약하면, **동기식에서는 작업을 요청한 함수가 작업 완료를 계속 확인하며 신경쓴다.** 

```c
Future ft = asyncFileChannel.read(~~~);

while(!ft.isDone()) {
    /*
        isDone()은 asyncChannle.read() 작업이 완료되지 않았다면 false를 바로 리턴한다.
        isDone()은 물어보면 대답을 해줄 뿐 작업 완료를 스스로 신경쓰지 않고,
        isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업 완료를 신경쓴다.
        asyncChannle.read()이 완료되지 않아도 여기에서 다른 작업 수행 가능 
    */
}

// asyncChannle.read() 작업이 완료되면, 작업 결과에 따른 다른 작업 처리
```

위의 코드를 보면 알 수 있듯이, 논블로킹 동기라고 해도 결국 B 함수의 작업이 완료되어야 A 함수의 다른 작업을 수행할 수 있다는 점에서, **동기식 모델은 작업이 순차적으로 진행된다**고 할 수 있다. 

다시 질문으로 돌아와서, 누가 어떤 시간을 맞춘다는 것일까? (동기라고 불리는 이유는?)

A 함수가 B 함수를 호출했으면, A 함수는 (시간이 얼마나 걸리더라도) B 함수의 **결과를 그 자리에서 받는다.** 이처럼 B 함수에게 **작업을 요청한 시점과 결과를 반환 받는 시점이 동일**하기 때문에, **동기**라고 부른다.

# Asynchronous

<img width="300" src="https://github.com/user-attachments/assets/d13ca353-4de7-4cce-8233-1366e6459955"/>

**비동기식 모델은 호출된 함수의 수행 결과 및 종료를, 호출된 함수가 직접 처리하는 것이다.**

비동기식 모델에서 A 함수가 B 함수를 호출하는 상황을 가정해보자. 

- B 함수의 작업 완료는 B 함수가 직접 혼자서 처리한다. 
- B 함수는 작업이 끝나면 그 결과를 A 함수에게 알릴 뿐이다. 
- A 함수는 B 함수의 작업 완료 여부를 신경쓰지 않기 때문에, B 함수를 호출한 후 다른 작업을 수행할 수 있다. 

요약하면, **비동기식 모델에서는 작업을 요청한 함수가 작업의 완료 여부를 신경쓰지 않고 자기 할일을 계속 한다.**

비동기식 모델에서는 **작업이 순차적으로 진행된다는 것을 보장할 수 없다.** B 함수가 끝나지 않았는데도 A 함수는 다른 작업을 수행할 수 있기 때문이다.

비동기라고 부르는 이유는 무엇일까?

A 함수가 B 함수를 호출하고, 다른 작업을 수행한 뒤에 B 함수가 완료될 수 있다. 이처럼 **B 함수에 작업을 요청한 시점과 결과를 반환 받는 시점이 다르기 때문에 비동기**라고 부른다. 

# 참고 이미지 

<img width="600" src="https://github.com/user-attachments/assets/7f0afbd7-434f-4714-bcc5-7ea18966d736"/>

<img width="500" src="https://github.com/user-attachments/assets/468470c9-0d0c-4e33-b821-b3433dddb2f0"/>
