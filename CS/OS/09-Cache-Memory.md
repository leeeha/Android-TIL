# 캐시 메모리 

캐시 메모리는 **속도가 빠른 장치와 느린 장치 간의 속도 차이에 따른 병목 현상을 줄이기 위한 범용 메모리**다. CPU와 메인 메모리 사이에 위치하며, 속도가 빠르지만 용량이 작고 비싸다.

캐시 메모리는 **메인 메모리에서 자주 사용하는 프로그램과 데이터를 저장**해둬서 속도를 빠르게 한다. 이를 위해 CPU가 어떤 데이터를 원하는지 어느정도 예측할 수 있어야 한다. 

- **Cache Hit**: CPU가 사용하려는 데이터가 실제로 캐시 메모리에 있는 경우
- **Cache Miss**: CPU가 사용하려는 데이터가 캐시 메모리에 없는 경우
  - Compulsory Miss: 특정 데이터에 처음 접근할 때 발생
  - Capacity Miss: 캐시 메모리의 공간이 부족할 때 발생
  - Conflict Miss: 데이터 A, B가 동일한 캐시 메모리 주소에 할당되어 있을 때 발생 
- **Cache Hit Rate**: Cache Hit Count / (Cache Hit Count + Cache Miss Count)

캐시의 적중률(Cache Hit Rate)에 따라 캐시의 성능이 결정된다.

# 캐시의 지역성 

캐시의 지역성이란, **데이터에 대한 접근이 시간적 또는 공간적으로 가깝게 발생하는 것**이다. 캐시의 적중률을 극대화하여 캐시가 효율적으로 동작하게 만드는 성질이다.

- **공간 지역성**: 최근에 사용했던 데이터와 **인접한 데이터**가 참조될 가능성이 높다. ex) 배열 
- **시간 지역성**: 최근에 사용했던 데이터가 **빠른 시간 내에 다시 참조**될 가능성이 높다. ex) for, while 같은 반복문 

# 캐싱 라인 

캐시가 아무리 CPU와 가까이 있어도 데이터가 캐시 내의 어느 곳에 저장되어 있는지 찾기가 어렵다면, 검색 시간이 오래 걸려서 캐시의 장점을 잃게 된다. 

따라서, 캐시에 데이터를 저장할 때 **특정 자료구조를 사용해 묶음으로 저장**하게 되는데, 이를 **캐싱 라인** (Caching Line)이라고 한다. 

- 인덱스: 캐시 메모리 내의 특정 캐싱 라인을 가리킴.
- 태그: 특정 캐싱 라인에 저장된 데이터가 정확히 어떤 메모리 블록에서 왔는지 식별하는 용도 

## Direct Mapping 

직접 매핑은 **일정한 크기의 블록으로 나눈 메인 메모리를 하나의 캐싱 라인에 매핑하는 방식**이다.

- 장점: 구현하기 쉽고, 인덱스에 따라 빠르게 접근 가능하다. 
- 단점: 하나의 캐싱 라인에 여러 메모리 블록이 매핑되므로, 충돌 미스가 발생할 가능성이 높다.

<img width="400" src="https://github.com/user-attachments/assets/6e656510-24b0-491b-9943-37fa56c94a10"/> 

## Full Associative Mapping

완전 연관 매핑은 **메인 메모리의 모든 블록을 어느 캐싱 라인에도 저장할 수 있는 방식**이다. 

- 장점: 충돌 미스가 발생하지 않는다.
- 단점: 인덱스가 없으므로, 태그를 이용해 캐시 내 모든 라인을 검색해야 한다.

## Set Associative Mapping 

위의 두 가지 방식의 절충안으로, 캐시 메모리를 여러 집합으로 나누고 각 집합은 여러 캐싱 라인으로 구성된다. 

즉, **메인 메모리의 각 블록은 특정한 집합에 매핑되지만, 집합 내에서는 어느 캐싱 라인에나 저장**될 수 있다. 

- 장점: 직접 매핑에 비해 충돌 미스가 줄어들고, 완전 연관 매핑에 비해 검색 시간이 줄어든다.
- 단점: 집합 내에 여러 캐싱 라인이 존재하므로, 직접 매핑에 비해서는 검색 시간이 길어질 수 있다.

# 참고 자료 

https://rebro.kr/180

https://velog.io/@kangdev/운영체제-캐싱-라인-Caching-line