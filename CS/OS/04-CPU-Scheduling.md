# CPU 스케줄링

<img width="700" src="https://github.com/user-attachments/assets/9948b4d8-cf90-4fed-a5ca-545532092a34"/> 

사용자 프로그램은 위의 그림처럼 **CPU 작업과 I/O 작업의 반복**으로 이루어진다. 

- CPU burst: CPU를 점유하여 빠른 연산 작업을 수행하는 단계 
- I/O burst: I/O 요청이 발생해 커널에 접근하여 입출력 작업을 수행하는 비교적 느린 단계 

CPU burst, I/O burst가 차지하는 비율에 따라 프로세스를 다음과 같이 구분할 수 있다.

- CPU bound 프로세스
  - I/O 작업을 거의 수행하지 않아 CPU burst가 길게 나타나는 프로세스 
  - 프로세스 수행 시간의 상단 부분을 CPU 작업에 소모하는 계산 위주의 프로그램에 해당
- I/O bound 프로세스
  - I/O 요청이 빈번하게 발생해 CPU burst가 짧게 나타나는 프로세스 
  - 주로 사용자와 지속적으로 상호작용하는 대화형 프로그램에 해당

우리가 사용하는 시분할 시스템에는 이와 같이 **CPU burst time이 일정하지 않은 프로세스가 공존하므로, 효율적인 CPU 스케줄링 기법이 반드시 필요**하다. 

대표적으로 CPU burst time이 짧은 프로세스에 우선적으로 CPU를 할당해 응답 시간을 높이고, I/O 장치의 효율성을 높이는 방식이 있다. 

# CPU 스케줄러

- 스케줄러란 **어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드**를 지칭한다.
- 스케줄러에는 장기 스케줄러, 중기 스케줄러, 단기 스케줄러가 있다.

## 스케줄러의 종류 

### 장기 스케줄러 (long-term)
  
장기 스케줄러는 **디스크 내의 작업을 어떤 순서로 메모리에 가져올지 결정**한다. 즉, 작업 큐에 있는 프로세스 중에 **어떤 것을 준비 큐에 진입시킬지 결정**한다. 

장기 스케줄러는 과거에 적은 양의 메모리를 사용하던 시절에 쓰였으며, 현대의 시분할 시스템에서는 사용되지 않는다. 

- 메모리와 디스크 사이의 스케줄링 담당
- 실행 빈도: 상대적으로 낮은 편 (초당 한번)
- 프로세스 상태 변화: New → Ready
- 사용 예시: 여러 작업을 일괄 처리하는 배치 시스템

### 중기 스케줄러 (mid-term)

현대의 시분할 시스템 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 둔다.

중기 스케줄러는 너무 많은 프로세스에 메모리를 할당하여 시스템 성능이 저하되는 문제를 해결하기 위해, **Swapping 기법으로 메모리에 적재된 프로세스 개수를 조절**한다. 

너무 많은 프로세스가 메모리에 적재되어 프로세스당 보유 메모리가 극도로 적어지면, 중기 스케줄러는 **메모리에 올라와 있는 프로세스 중 일부를 디스크로 swap out** 시킨다.    

- 실행 빈도: 중간 정도 (메모리 상태에 따라 필요할 때 실행)
- 프로세스 상태 변화: Ready → Suspended
- Suspended 상태: 외부적인 이유로 프로세스가 디스크로 swap out 되어 실행이 중단된 상태. Blocked 상태의 프로세스는 I/O 작업이 끝나면 Ready 상태로 돌아갈 수 있지만, Suspended 상태에서는 스스로 돌아갈 수 없다. 

### 단기 스케줄러 (short-term)

단기 스케줄러는 **준비 큐에 있는 여러 프로세스 중에 어떤 프로세스에 CPU를 할당하여 실행시킬지 결정**한다. 

단기 스케줄러가 프로세스를 선정하면, 디스패처가 CPU를 해당 프로세스에게 할당한다.

- 메모리와 CPU 사이의 스케줄링 담당 
- 실행 빈도: 매우 자주 실행 (수 밀리초마다 한번)
- 프로세스 상태 변화: Ready → Running → Waiting → Ready
- 사용 예시: 반응형, 시분할 시스템 (FCFS, SJF, RR 등)

## 비선점형 vs 선점형 

- 비선점형 스케줄링: CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 스케줄러가 강제로 프로세스를 쫓아낼 수 없다.  
- 선점형 스케줄링: 프로세스가 CPU를 계속 사용하길 원하더라도 스케줄러가 강제로 CPU를 빼앗을 수 있다. 

<img width="450" src="https://github.com/user-attachments/assets/0f5c0430-d0d6-43f1-b1c4-58b8f153c864"/>

1. running → I/O 요청 → waiting (비선점형)
2. running → 타이머 인터럽트 → ready (선점형)
3. waiting → I/O 작업 완료 → ready (선점형)
4. terminated (비선점형)

## 디스패처

CPU 디스패처는, **스케줄러에 의해 선택된 프로세스가 CPU를 할당받아 작업을 수행할 수 있도록 환경을 설정하는 운영체제 코드**를 의미한다.

디스패처는 **문맥 교환이 있을 때마다 호출**되기 때문에 가능한 속도가 빨라야 한다. 

**한 프로세스를 정지시키고 다른 프로세스를 실행시킬 때까지 걸리는 시간**인 **디스패치 지연시간** (dispatch latency)를 최소화 하는 것이 중요하다. 

<img width="600" src="https://github.com/user-attachments/assets/0828a33d-01c3-4857-8d7f-bf3d94c23602"/> 

# CPU 스케줄링 알고리즘

## 스케줄링 성능 평가 

- CPU 사용률 (CPU utilization): 전체 시간 중에 CPU가 일한 시간의 비율 
- 처리량 (Throughput): 주어진 시간 동안 CPU burst를 완료한 프로세스의 개수 
- 처리 시간 (Turnaround time): 준비 큐에서 대기한 시간 + CPU 할당 받아 실행된 시간 
- 대기 시간 (Waiting time): 준비 큐에서 대기한 시간의 총합 
- 응답 시간 (Response time): 프로세스가 준비 큐에 도착한 후 처음 CPU를 할당 받기까지 걸린 시간

## 스케줄링의 목표 

- CPU 사용률, 처리량 최대화 
- 처리 시간, 대기 시간, 응답 시간 최소화 

## FCFS (First-Come, First-Served)

### 정의 

- **Ready Queue에 도착한 프로세스 순서대로 CPU를 할당하는 방식** (선착순)
- 구현하기 가장 간단한 CPU 스케줄링 알고리즘 (FIFO 큐로 구현 가능)

### 특징 

- 프로세스가 자신의 작업이 완료될 때까지 CPU를 반납하지 않으므로 **비선점형** 알고리즘 
- CPU burst time이 가장 큰 CPU bound 프로세스가 첫번째로 CPU를 선점하면, 그 뒤의 모든 I/O bound 프로세스들은 계속 대기해야 하므로 비효율적이다. (Convoy Effect)

## SJF (Shortest Job First)

### 정의 

**CPU burst time이 가장 작은 프로세스부터 먼저 처리하는 알고리즘** (CPU burst time이 동일하면, FCFS에 따라 선착순으로 처리)

이를 구현하기 위해서는 각 프로세스의 CPU burst time을 알아야 하는데, 정확한 값을 알 수 없기 때문에 **과거의 CPU burst time을 통해 미래의 값을 예측하는 방식**으로 구한다. 

<img height="220" src="https://github.com/user-attachments/assets/d8edca5b-fb33-4d57-9b66-8da144e2871a"/>
<img height="250" src="https://github.com/user-attachments/assets/ace0b9e9-0346-4f02-900c-cfdec97ed0ff"/>

### 특징 

- **비선점형** 알고리즘 
- CPU burst time이 상대적으로 긴 프로세스가 Ready Queue에서 무한정 대기하는, **기아 현상** (starvation)이 발생할 수 있다. 

## SRTF (Shortest Remaining Time First) 

### 정의 

**선점형 SJF 알고리즘**으로, **현재 실행되고 있는 프로세스의 남은 시간보다 새로 들어온 프로세스의 CPU burst time이 더 작을 때, 새로운 프로세스가 CPU를 선점**한다. 

### 특징 

- **선점형** 알고리즘 
- SJF와 마찬가지로 **기아 현상** 발생 가능 
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시 하기 때문에, CPU burst time 측정이 어렵다.

## Priority-base

### 정의 

- **프로세스에 주어진 우선순위에 따라 스케줄링 한다.** (여러 프로세스의 우선순위가 동일하다면 FCFS 알고리즘 수행) 
- **SJF, SRTF 모두 우선순위 기반 스케줄링**의 일종이다. **CPU burst time이 작을수록 우선순위가 높은 것**이다. 

### 특징 

- 선점형 방식 : 더 높은 우선순위의 프로세스가 Ready Queue에 도착하면, 실행 중인 프로세스를 멈추고 새로운 프로세스가 CPU를 선점한다. 
- 비선점형 방식 : 더 높은 우선순위의 프로세스가 도착하면, Ready Queue의 Head 위치에 프로세스를 배치한다. 
- 우선순위가 낮은 프로세스가 Ready Queue에서 무한정 대기하는 **기아 현상** 발생 가능 
- 기아 현상의 한 가지 해결 방법으로는, **프로세스의 대기 시간에 비례해서 우선순위를 점진적으로 늘려주는** **Aging**이 있다. 

## RR (Round-Robin)

### 정의 

- **할당 시간(time quantum)이 있는 선점형 FCFS** 
- 스케줄러가 원형 큐인 Ready Queue를 돌면서 **time quantum 간격으로 각 프로세스에 CPU를 할당**한다. 
- 현대적인 CPU 스케줄링 알고리즘 

### 특징 

- CPU burst time <= time quantum : 프로세스가 자발적으로 CPU를 반환하고, 스케줄러는 레디 큐의 다음 프로세스로 넘어감. 
- CPU burst time > time quantum : **타이머가 종료되어 OS에 인터럽트 발생 → 레디 큐에 있던 다른 프로세스가 CPU 선점 (컨텍스트 스위칭)** → 원래 프로세스는 레디 큐의 Tail 위치에 추가 
- **time quantum 크기에 따라 성능이 크게 달라진다.** 할당 시간이 너무 길면 FCFS랑 동일해지고, 할당 시간이 너무 작으면 프로세스 간의 컨텍스트 스위칭이 빈번하게 발생하여 dispatch latency가 커진다. 

## Multi-Level Queue (MLQ)

<img width="700" src="https://github.com/user-attachments/assets/d9a05d74-7284-49b8-aae2-a3aa35a56de9"/>

멀티 레벨 큐란 **준비 큐를 여러 개의 레벨로 분류**하여 관리하는 스케줄링 기법이다. 

즉, 프로세스들이 CPU를 기다리며 한 줄로 서는 것이 아니라 **여러 줄로 서는 것**이다.

- 전위 큐 
  - 사용자와 상호작용하는 대화형 작업
  - 응답 시간이 짧아야 하므로, RR (Round Robin) 스케줄링 적용 
- 후위 큐
  - 계산 위주의 작업
  - 컨텍스트 스위칭 오버헤드를 줄이기 위해, FCFS 스케줄링 적용 

<img width="700" src="https://github.com/user-attachments/assets/1da8a598-5865-4b46-a665-088091d31ac3"/>

프로세스에 대한 스케줄링 뿐만 아니라 **준비 큐 자체에 대한 스케줄링**도 필요하다. 

- 고정 우선순위 방식
  - 준비 큐마다 우선순위를 부여하여 스케줄링 
  - 우선순위가 낮은 큐는 무한정 대기하는 기아 현상 발생 가능 
- 타임 슬라이스 방식 
  - 준비 큐에 CPU 시간을 적절한 비율로 분배하여 스케줄링 (기아 현상 방지)
  - 예를 들어 전위 큐에는 80%, 후위 큐에는 20% 할당 
  
## Multi-Level Feedback Queue (MLFQ)

<img width="700" src="https://github.com/user-attachments/assets/16f487f4-edbf-449c-ac3c-51c3e1da028c"/>

멀티 레벨 큐처럼 CPU를 기다리는 프로세스를 여러 큐에 줄 세우며, 추가적으로 멀티 레벨 피드백 큐는 **프로세스가 하나의 큐에서 다른 큐로 이동**할 수 있다. 

Aging 기법을 적용하여 **우선순위가 낮은 큐에서 오래 대기한 경우 우선순위가 높은 큐로 이동**시킨다. 

- 프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐에 줄을 선다. 
- CPU burst time이 짧은 프로세스는 RR 스케줄링으로 빠르게 처리한다. 
- CPU burst time이 긴 프로세스는 할당 시간이 더 길게 설정된 하위 큐로 이동하여 다시 줄을 선다.
- 해당 큐에서도 CPU 작업이 완료되지 않으면, 계산 위주의 프로세스로 간주되어 최하위 큐에서 FCFS 스케줄링으로 처리한다. 

이렇게 **프로세스의 CPU burst time에 따라 준비 큐를 여러 레벨로 분류**함으로써

**작업 시간이 짧은 프로세스**에 대해서는, RR 스케줄링으로 **빠른 응답 시간을 보장**하고 

**작업 시간이 긴 프로세스**에 대해서는, FCFS 스케줄링으로 문맥 교환 오버헤드를 줄여 **CPU 작업에만 열중**하게 만들 수 있다. 

# 면접 예상 질문 

<details>
<summary>기아 상태가 무엇인가요?</summary>

우선순위가 낮은 프로세스가 계속 CPU를 할당 받지 못하고 Ready Queue에서 무한정 대기하는 상태 

</details>
<br>

<details>
<summary>기아 상태를 어떻게 해결할 수 있나요?</summary>

프로세스의 대기 시간에 비례하여 우선순위를 점진적으로 늘려주는 Aging 기법 

</details>
<br>

<details>
<summary>CPU 스케줄링에 대해 설명해주세요.</summary>

CPU 스케줄러가 준비 큐에 있는 프로세스 중에 어떤 프로세스에 CPU를 할당할지 결정하는 것

프로세스가 처리하는 작업의 특성마다 CPU burst time이 다르기 때문에 이를 적절한 순서로 배치하여 

사용자에게 빠른 응답성을 보장하고, CPU와 I/O 장치의 효율성을 증가시킬 수 있다. 

</details>
<br>

<details>
<summary>스케줄러의 종류는 무엇이 있나요?</summary>

- 장기 스케줄러: 디스크에 있는 프로세스 중에 어떤 프로세스를 준비 큐로 보낼지 결정 (메모리가 부족했던 과거에 사용)
- 중기 스케줄러: 스와핑 기법으로 메모리에 올라간 프로세스 개수 조절 
- 단기 스케줄러: 준비 큐에 있는 프로세스 중에 어떤 프로세스에 CPU를 할당할지 결정  

</details>
<br>

<details>
<summary>선점형 스케줄링과 비선점형 스케줄링의 차이가 무엇인가요?</summary>

- 선점형 스케줄링: 프로세스가 계속 CPU를 사용하고 싶어도, 스케줄러에 의해 강제로 CPU를 빼앗을 수 있다.
- 비선점형 스케줄링: 프로세스가 자발적으로 CPU를 반납하기 전까지는, 스케줄러가 강제로 프로세스의 CPU를 빼앗을 수 없다. 

</details>
<br>

<details>
<summary>선입선출 스케줄링(FCFS)에 대해 설명해주세요.</summary>

- 준비 큐에 도착한 순서대로 프로세스에 CPU를 할당하는 방식 (선착순)
- 비선점형 스케줄링
- CPU burst time이 긴 프로세스에 의해 그 다음 I/O 프로세스가 오랫동안 실행되지 못하는 Convoy Effect 발생 가능 

</details>
<br>

<details>
<summary>최단 작업 우선 스케줄링(SJF)에 대해 설명해주세요.</summary>

- CPU burst time이 가장 작은 프로세스부터 먼저 처리하는 방식 
- 비선점형 스케줄링 
- CPU burst time이 상대적으로 긴 프로세스가 준비 큐에서 무한정 대기하는 기아 현상 발생 가능 

</details>
<br>

<details>
<summary>최소 잔류 시간 우선 스케줄링(SRTF) 방식에 대해 설명해주세요.</summary>

- 현재 실행 중인 프로세스의 남은 시간보다 새로 들어온 프로세스의 CPU burst time이 더 작으면 현재 프로세스가 선점되는 방식 
- 선점형 SJF 스케줄링 
- Remaing Time이 작은 프로세스부터 먼저 처리되기 때문에 기아 현상 발생 가능 

</details>
<br>

<details>
<summary>우선순위 스케줄링에 대해 설명해주세요.</summary>

- 우선순위가 높은 프로세스부터 먼저 처리되는 방식 
- 선점형, 비선점형 스케줄링 모두 가능 
- 기아 현상 발생 가능 

</details>
<br>

<details>
<summary>라운드 로빈 스케줄링에 대해 설명해주세요.</summary>

- 스케줄러가 원형 레디 큐를 돌면서 할당 시간에 따라 프로세스에 CPU를 할당하는 방식
- 선점형 FCFS 알고리즘
- 여러 프로세스가 할당 시간에 따라 돌아가면서 실행되기 때문에 사용자에게 빠른 응답 가능 
- 할당 시간이 너무 길면 FCFS와 동일, 할당 시간이 너무 짧으면 문맥 교환 오버헤드 증가 

</details>
<br>

<details>
<summary>멀티 레벨 큐 스케줄링에 대해 설명해주세요.</summary>

- 프로세스가 CPU를 할당 받기 위해 여러 줄로 서서 대기하는 것 
- 준비 큐를 여러 개의 레벨로 분류하여 스케줄링 
- 전위 큐에서는 응답 시간이 짧아야 하는 대화형 작업, 후위 큐에서는 계산 위주의 배치 작업 수행 
- 준비 큐 자체의 스케줄링: 고정 우선순위 방식, 타임 슬라이스 방식 

</details>
<br>

<details>
<summary>멀티 레벨 피드백 큐 스케줄링에 대해 설명해주세요.</summary>

어떤 프로세스가 CPU를 할당 시간 내에 끝내지 못하면, CPU burst time이 긴 프로세스로 간주하여 우선순위가 낮은 큐로 이동시킨다. 

이때 우선순위가 낮은 준비 큐에서 너무 오래 기다린 프로세스는 다시 우선순위가 높은 준비 큐로 올려보내는 Aging 기법을 적용하여 기아 현상을 방지한다.

</details>
<br>

# 참고자료 

https://velog.io/@jxlhe46/OS-Ch05.-CPU-스케줄링

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/main/OS

