# 주소 바인딩 

프로세스의 주소는 **논리적 주소**와 **물리적 주소**로 나뉜다. 

- 논리적 주소: 가상 주소, CPU에서 할당하는 주소, 프로세스마다 독립적으로 가지는 주소 공간 
- 물리적 주소: 프로세스가 실행되기 위해 실제로 메모리(RAM) 위에 올라가는 위치 

주소 바인딩은 **프로그램을 메모리의 어느 위치(물리적 주소)에 로드할지 결정하는 과정**이다.

- 컴파일 타임 바인딩: 프로세스의 물리적 주소가 컴파일 타임에 결정된다. 프로세스 내부에서 사용하는 논리적 주소와 물리적 주소가 동일하다.
- 로드 타임 바인딩: 프로세스를 메모리에 로드하는 시점에 물리적 주소가 결정된다. 
- 런타임 바인딩: 프로그램이 실행되는 런타임에 프로세스의 물리적 주소가 결정되며, 실행 도중에 주소가 바뀔 수 있다. 

컴파일 타임, 로드 타임 주소 바인딩은 실제로 잘 쓰이지 않는다. 

런타임 주소 바인딩 과정에서는 **MMU(Memory Management Unit)이라는 하드웨어 장치를 사용하여 논리적 주소를 물리적 주소로 변환**한다. 

프로세스가 실행되면서 CPU가 생성하는 **모든 논리적 주소에 대해 base register 값을 더해서 물리적 주소를 생성**하는 방식이다. 여러 프로세스는 하나의 base register를 공유한다. 

<img width="500" src="https://github.com/user-attachments/assets/f0004934-6c78-405a-8857-e3ec7816f338"/>

<img width="500" src="https://github.com/user-attachments/assets/eaeadd73-0c18-4602-803e-8f931aee9381"/>

Limit register는 **논리적 주소의 최댓값**이며, 잘못된 메모리 주소를 참조하지 않도록 막아준다. 

Base (Relocation) register는 **접근 가능한 물리적 주소의 최솟값**이다. 

커널 모드인 경우에는 MMU가 논리적 주소를 그대로 물리적 주소로 사용한다. 따라서 커널 모드인지 확인하는 과정도 포함되어 있다. 

# Swapping  

메모리는 크기가 크지 않기 때문에 **프로세스를 임시로 디스크로 내보냈다가 (Swap Out)**, **다시 메모리로 로드해야 (Swap In)** 하는 상황이 생긴다. 

스와핑에 걸리는 대부분의 시간은 **디스크 전송 시간**이다. 컴파일이나 로드 타임 주소 바인딩은 원래 메모리 위치로 Swap In 해야 하지만, 런타임 주소 바인딩은 임의의 비어있는 메모리 위치로 Swap In 할 수 있다. 

# Fragmentation

Fragmentation(단편화)은 **프로세스들이 메모리에 적재되고 제거되는 일이 반복되면서, 프로세스들이 차지하는 메모리 공간 사이에 사용하지 못할 작은 틈이 늘어나게 되는 현상**을 말한다. 

- **외부 단편화**: 남아있는 메모리 공간의 크기를 합치면 프로세스를 할당할 수 있지만, 해당 공간들이 연속되어 있지 않아서 사용하지 못하는 경우 
- **내부 단편화**: 프로세스가 사용하는 메모리 공간보다 분할된 공간이 더 커서 메모리가 남는 경우 

<img width="500" src="https://github.com/user-attachments/assets/027b2cb2-fb61-4faa-82b4-658a89d40d88"/>

외부 단편화를 해결하기 위해 **프로세스가 사용하는 메모리 공간을 한쪽으로 몰아서 자유 공간을 확보하는 Compaction(압축) 방법**이 있지만, 작업 효율이 좋지 않다. 

# Paging 

페이징은 외부 단편화를 해결하는 압축 방법의 비효율성을 해결하기 위한 방법론으로, **불연속적인 메모리 할당 방식**이다. 

페이징에서 메모리는 프레임(frame), 프로세스는 페이지(page)라고 불리는 일정한 크기의 블록으로 잘리게 된다.

**한 프로세스가 사용하는 메모리 공간은 여러 페이지로 나눠서 관리되고, 각 페이지는 순서와 관계없이 메모리의 프레임에 매핑되어 할당된다.** 

프로세스가 메모리에 연속적으로 할당되어 있지 않기 때문에, 특정 프로세스를 실행하려면 **페이지가 메모리의 어느 프레임에 위치해 있는지** 알아야 한다. 이에 대한 정보가 **page table**에 저장되어 있고, 이를 통해 논리적 주소를 물리적 주소로 변환한다.

이러한 페이징 기법을 통해 CPU는 마치 프로세스가 연속된 메모리 공간에서 동작하는 것처럼 착각하게 된다. 

<img width="400" src="https://github.com/user-attachments/assets/979ee7b2-2254-4045-8a93-4d58f303c243"/>

- 메모리 상에 페이지가 연속적으로 할당될 필요가 없어서, **외부 단편화 문제를 해결**할 수 있다.
- 내부 단편화 문제는 여전히 해결하지 못하며, **page table을 저장하기 위한 추가 메모리 공간이 필요**하다. 
- 메모리에 상주하는 page table에 접근하여 물리적 주소를 얻는 과정이 추가되기 때문에 속도가 느리다.
- 속도 향상을 위해 TLB(Translation Look-aside Buffer)라고 불리는 고속의 하드웨어 캐시를 사용한다. 

# Segmentation 

**페이지**가 **프로세스를 일정한 간격으로 자르는 물리적 단위**였다면, **세그먼트**는 **프로세스를 의미가 같은 영역으로 자르는 논리적 단위**라고 볼 수 있다. 

따라서 일반적으로 각 세그먼트의 크기는 다르며, Code, Data, Stack, Heap 영역을 각각 하나의 세그먼트라고 할 수 있다. 

프로세스를 분할하는 방식 외에 **프로세스를 메모리에 할당하는 방법은 페이징과 동일**하다. 세그먼트 테이블에 저장된 시작 위치와 변위 값을 합하여 물리 주소를 구할 수 있는데, 이 주소가 limit(각 세그먼트의 크기)를 넘으면 예외 처리를 하게 된다.

<img width="600" src="https://github.com/user-attachments/assets/14132c15-f8ca-4fc8-84b8-24adf2d275bc"/>

서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되면서, **외부 단편화 문제가 발생**할 수 있다. 이 문제를 해결하기 위해 **세그먼트를 페이징 하는 방법**을 취할 수 있다.

<img width="600" src="https://github.com/user-attachments/assets/d29987ba-f88c-4ba6-a465-eb93966cf5b1"/>

처음에 프로세스를 세그먼트 단위로 자른다. 이 상태로는 외부 단편화가 발생할 수 있으므로, 각 세그먼트를 다시 일정한 간격의 페이지로 자른다. 

이 방법은 테이블 2개를 모두 거쳐야 하므로 속도 면에서는 성능이 떨어질 수 있다.

# 참고자료 

https://rebro.kr/178

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/main/OS

https://copycode.tistory.com/108