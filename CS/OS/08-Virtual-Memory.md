# 개념 정리 

https://velog.io/@jxlhe46/OS-Ch10.-가상-메모리

# 면접 예상 질문 

<details>
<summary>가상 메모리에 대해 설명해주세요.</summary>

프로그램 전체를 메모리에 적재하여 실행시키는 기존 방식은, 물리적 메모리 크기가 제한적이라는 점에서 매우 비효율적이었다. 

가상 메모리 기법에서는 프로그램 실행에 필요한 일부만 메모리에 적재하고, 나머지는 디스크에 두는 방식으로 물리적 메모리 크기의 한계를 극복한다. 

즉, 디스크의 스왑 영역을 물리적 메모리의 연장선으로 사용하는 것이다. 

CPU 입장에서는 프로그램 전체가 메모리에 적재된 것처럼 보이기 때문에 가상 메모리라고 부른다. 

</details>
<br>

<details>
<summary>가상 주소와 물리 주소(실주소)에 대해 설명해주세요.</summary>

- 가상 주소 (논리 주소): CPU에 의해 생성된 주소 
- 물리 주소: 실제 메모리에 할당된 주소 

</details>
<br>

<details>
<summary>가상 주소를 물리 주소(실주소)로 어떻게 변환할까요?</summary>

MMU라는 하드웨어 장치에 있는 relocation register를 이용해, 가상 주소로부터 물리 주소를 구할 수 있다. 

</details>
<br>

<details>
<summary>페이지 교체에 대해서 설명해주세요.</summary>

**프로세스 실행에 필요한 페이지가 현재 메모리에 올라와 있지 않은 상황**을 **페이지 부재**라고 한다. 

이때 디스크에 접근하여 필요한 페이지를 메모리로 읽어와야 하는데, 메모리에 비어있는 프레임이 없을 때는 **기존 페이지 중 하나를 디스크로 쫓아내서 빈 공간을 마련**해야 한다. 

이러한 작업을 페이지 교체라고 한다. 

</details>
<br>

<details>
<summary>페이지 부재를 최소화하려면 어떻게 해야 하나요?</summary>

페이지 부재를 최소화 하려면 **자주 참조되는 페이지들이 메모리에 올라와 있어야 한다.** 

이를 위해 클럭, FIFO, LRU, LFU 같은 페이지 교체 알고리즘을 적용할 수 있다.

</details>
<br>

<details>
<summary>페이지 교체 알고리즘 FIFO에 대해 설명 해주세요.</summary>

가장 먼저 메모리에 적재되었던 페이지부터 교체하는 방식 

가까운 미래에 다시 참조될 가능성이 높은 페이지도 그냥 교체해버린다는 점에서 비효율적 

페이지 프레임 개수가 늘어났는데 페이지 부재율이 증가하는 이상 현상이 발생하기도 함. 

</details>
<br>

<details>
<summary>페이지 교체 알고리즘 LRU에 대해 설명 해주세요.</summary>

가장 오랫동안 참조되지 않은 페이지부터 교체하는 방식 

최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높다는 시간 지역성을 기반으로 함. 

참조 빈도수가 높은 페이지인데 최근에 참조가 안 되었다는 이유로 페이지를 교체하는 문제 발생 

</details>
<br>

<details>
<summary>페이지 교체 알고리즘 LFU에 대해 설명 해주세요.</summary>

가장 적게 참조된 페이지부터 교체하는 방식   

앞으로 자주 참조될 페이지를 지금까지 참조 빈도수가 낮았다는 이유로 교체하는 문제 발생 

</details>
<br>

<details>
<summary>페이지 교체 알고리즘 클럭 알고리즘에 대해 설명해주세요.</summary>

오랫동안 참조되지 않은 페이지 중에 하나를 교체하는 방식 

원형 큐를 돌면서 참조 비트가 0인 페이지를 교체한다. 

참조 비트가 1인 페이지는 바로 교체하지 않고 참조 비트를 0으로 변경한다. 한바퀴 돌고 다시 돌아왔을 때도 참조 비트가 0이면 교체한다.

적어도 원형 큐를 한바퀴 도는 시간 동안은 최근에 참조된 페이지가 교체되지 않도록 보장한다. 

</details>
<br>

<details>
<summary>쓰레싱에 대해 설명해주세요.</summary>

너무 많은 프로세스가 한꺼번에 메모리에 적재되면, 한 프로세스에 할당할 수 있는 메모리 크기가 줄어든다. 

각 프로세스의 실행에 필요한 최소한의 페이지 프레임도 할당 받지 못하면, 페이지 부재율이 크게 상승하고 CPU 사용률은 급격히 낮아지는데 이를 스레싱이라고 한다. 

CPU 사용률이 낮아지는 이유는, 페이지 부재를 해결하기 위해 디스크 I/O 작업이 빈번하게 발생하면서 CPU가 하는 일 없이 놀기 때문이다. 

</details>
<br>

<details>
<summary>워킹셋 알고리즘에 대해 설명해주세요.</summary>

프로세스의 실행 중에 **집중적으로 참조되는 페이지들의 집합**을 **지역성 집합**이라고 부르는데, 이들이 **메모리에 한꺼번에 올라갈 수 있도록 보장**하는 알고리즘 

지역성 집합이 한꺼번에 메모리에 올라갈 수 있을 때만 프로세스에 메모리를 할당하고, 그렇지 않으면 프로세스의 주소 공간 전체를 디스크로 스왑 아웃시킨다. 

이를 통해 **멀티 프로그래밍의 정도를 조절**하여, **CPU 사용률을 높이면서도 스레싱을 방지**할 수 있다. 

</details>
<br>

<details>
<summary>페이지 부재 빈도 알고리즘에 대해 설명해주세요.</summary>

프로세스의 **페이지 부재율을 주기적으로 확인**하여, **각 프로세스에 할당할 메모리 크기를 동적으로 조절**하는 것이다. 

프로세스의 페이지 부재율이 상한선을 넘어가면, 프레임 개수가 부족하다고 판단해 프로세스에 프레임을 추가로 할당한다. 

프로세스의 페이지 부재율이 하한선보다 내려가면, 프레임이 과하게 할당되었다고 판단해 프로세스의 프레임 개수를 줄인다. 

이를 통해 **프로세스에 적절한 크기의 프레임을 할당**하여, **CPU 사용률을 높이면서도 스레싱을 방지**할 수 있다. 

</details>
<br>

