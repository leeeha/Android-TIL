# SOLID 원칙이란?

SOLID 원칙이란 **객체지향 설계에서 지켜야 할 5개의 소프트웨어 개발 원칙**을 말한다. 

- **S**RP (Single Responsibility Principle): 단일 책임 원칙
- **O**CP (Open Closed Principle): 개방 폐쇄 원칙
- **L**SP (Listov Substitution Priciple): 리스코프 치환 원칙
- **I**SP (Interface Segregation Principle): 인터페이스 분리 원칙
- **D**IP (Dependency Inversion Principle): 의존성 역전 원칙

SOLID 원칙을 준수하면 **코드를 확장하거나 유지보수하기 더 쉬워지며**, 불필요한 복잡성을 제거해 **소프트웨어 개발의 생산성**도 높일 수 있다. 

참고로 각 원칙은 특정 문제를 해결하기 위한 지침일 뿐이며, 반드시 5가지 원칙을 모두 적용해야 하는 건 아니다. 소프트웨어의 문제 상황에 따라 유동적으로 적용하면 된다. 그리고 각 원칙은 서로 독립적인 개념이 아니라 서로 긴밀하게 연결되어 있다.

## 단일 책임 원칙 - SRP

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/f694e7e0-e6c0-448f-a193-20d84a2ec691"/>

- 단일 책임 원칙은 **클래스는 단 하나의 책임만 가져야 한다**는 원칙이다.
- 여기서 ‘책임’이란 하나의 ‘기능’이라고 이해할 수 있다.
- 즉, **하나의 클래스는 하나의 기능만 담당하여 하나의 책임을 수행하는데 집중**하도록 소프트웨어를 설계하라는 원칙이다.

예를 들어, 하나의 클래스가 여러 책임(기능)을 맡고 있다면 어떤 일이 발생할까? 

클래스 A를 고쳤더니 B를 수정해야 하고, 이어서 C도 수정해야 하고, 다시 A로 돌아가서 또 수정해야 하는… 마치 책임이 순환되는 형태가 될 수 있다. 

따라서, SRP 원칙을 따름으로써 한 책임의 변경으로 인해 다른 책임까지 변경해야 하는 연쇄 작용 문제를 극복할 수 있다.

이때 책임(기능)의 범위는 딱 정해져 있는 게 아니고, 어떤 프로그램을 개발하는지에 따라 개발자마다 기준이 달라질 수 있다. 따라서 SRP에 100% 해답 같은 건 존재하지 않는다. 

## 개방 폐쇄 원칙 - OCP

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/bb9b60cf-b735-425a-b1e3-d9e9d1905dc2"/>

- 개방 폐쇄 원칙은 **클래스는 확장에 열려있어야 하고, 수정에 닫혀있어야 한다**는 원칙이다.
- 기능 추가 요청이 들어오면, **클래스를 쉽게 확장할 수 있으면서도 그에 따른 변경사항은 최소화** 되도록 프로그램을 설계해야 한다는 원칙이다.
- OCP 원칙은 **추상화와 상속**을 통해 구현할 수 있다. 즉, **자주 변하는 부분을 추상화** 함으로써 **기존 코드를 수정하지 않고도 기능을 확장**할 수 있는 유연한 구조를 설계하는 것이다.

## 리스코프 치환 원칙 - LSP

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/334a17bd-0faa-4ef4-938d-627f13a89969"/>

- 리스코프 치환 원칙은 **하위 타입은 언제나 상위 타입으로 교체할 수 있어야 한다**는 원칙이다. (다형성을 지원하기 위한 원칙)
- 상위 클래스 타입으로 객체를 선언하고 실제로는 하위 클래스 타입의 인스턴스를 받았을 때, **하위 클래스는 상위 클래스의 메서드를 본래 의도에 맞게 수행**해야 한다. 
- 하위 클래스가 상위 클래스의 메서드를 **본래 의도와 다르게 오버라이딩 하면, 예기치 못한 에러가 발생**할 수 있다.
- 상속 관계(IS-A)가 아닌 클래스 간에는 이 원칙이 성립하지 않는다. ex) [정사각형이 직사각형을 상속](https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle) 받는 경우, LSP에 위배된다. 

## 인터페이스 분리 원칙 - ISP

<img width="600" src="https://github.com/leeeha/Android-TIL/assets/68090939/e2b2ea36-c7bf-4608-b4aa-4a1f63476391"/>

- 인터페이스 분리 원칙은 **인터페이스를 각 용도에 맞게 잘 분리해야 한다**는 원칙이다.
- SRP 원칙이 **클래스의 단일 책임**을 강조한다면, ISP 원칙은 **인터페이스의 단일 책임**을 강조하는 것이다.
- 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다. 즉, 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.
- 인터페이스는 클래스와 달리 다중 상속(구현)이 가능하기 때문에, **분리할 수 있으면 최대한 분리하여 각 클래스의 용도에 맞게 구현하라**는 원칙이다.

## 의존성 역전 원칙 - DIP

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/d73a0b17-f982-4cfa-854a-fc296d9c8382"/>

- 의존성 역전 원칙은 **변하기 쉬운 구현체보다 변하기 어려운 추상 클래스나 인터페이스에 의존해야 한다**는 원칙이다.
- 상위 수준의 모듈이 하위 수준 모듈의 구현체에 직접적으로 의존해서는 안 된다.
- 하위 수준의 모듈이 변경되어도 상위 수준의 모듈은 영향을 받지 않아야 한다.
- DIP를 통해 **각 클래스 간의 결합도를 낮출 수 있다.**

## 총 정리

**SRP와 ISP는 객체가 커지는 것을 막아준다.** 객체가 하나의 책임을 갖도록 하고, 클라이언트마다 특화된 인터페이스를 구현하게 함으로써, **한 기능의 변경이 다른 곳까지 미치는 영향을 최소화** 한다. 이를 통해 **기능의 추가 및 변경을 용이하게** 만들 수 있다. 

**LSP와 DIP는 OCP를 서포트 한다.** OCP는 자주 변하는 부분을 추상화 하고 다형성을 이용함으로써 **기능 확장에는 용이하되, 기존 코드의 변경사항은 최소화** 한다. 여기서 ‘자주 변하는 부분을 추상화’ 할 수 있게 도와주는 원칙이 DIP이고, ‘다형성’ 구현을 도와주는 원칙이 LSP인 것이다. 

# 참고자료

https://inpa.tistory.com/entry/OOP-💠-객체-지향-설계의-5가지-원칙-SOLID

https://velog.io/@haero_kim/SOLID-원칙-어렵지-않다
