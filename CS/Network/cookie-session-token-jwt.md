# 쿠키 / 세션 / 토큰 인증 방식

## 쿠키

쿠키는 **key-value 형태의 문자열**이며, 클라이언트가 어떤 웹사이트에 방문할 때, 해당 웹사이트의 **서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일**이다. 각 사용자마다 브라우저에 쿠키를 저장하고 있으므로 해당 정보로 **유저의 고유 정보 식별**이 가능하다.

### 쿠키 인증 방식

<img width="700" src="https://github.com/leeeha/Android-TIL/assets/68090939/408b27d1-d6e6-4d0f-9a4b-3a7efcfd3105"/>

1. 브라우저(클라이언트)가 서버에 (접속) 요청을 보낸다. 
2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, **클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.** 
3. 이후 클라이언트는 서버에 요청을 보낼 때마다 **브라우저에 저장된 쿠키를 요청 헤더에 같이 담아서 보낸다.** 서버는 해당 쿠키에 담긴 정보를 바탕으로 **이 요청의 클라이언트가 누군지 식별**하거나, 유저의 특징에 맞게 추천 광고 등을 띄운다. 

### 쿠키 인증 방식의 단점

- **가장 큰 단점은, 보안에 취약하다는 것이다.** (클라이언트가 서버에 요청 시, 쿠키의 값을 그대로 보내기 때문에 외부에 유출 및 조작될 가능성이 있다.)
- 쿠키에는 **용량 제한**이 있어서 많은 정보를 담기 어렵다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르므로 **서로 다른 브라우저 간 공유가 불가능**하다.
- 쿠키의 사이즈가 커질수록 **네트워크 부하**가 심해진다.

## 세션

이러한 쿠키의 보안적 이슈로 인해, 세션은 비밀번호 등 **클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리**한다. (서버의 메모리, 로컬 파일, 데이터베이스 등에 저장)

**핵심은 민감한 정보는 클라이언트에 보내지 않고, '서버에서' 모두 관리한다는 점이다!** 

<details>
<summary>세션 객체는 어떤 형태로 이루어져 있을까?</summary>
<div markdown="1">

  - key: SESSION ID
  - value: 세션 생성 시간, 마지막 접근 시간, 유저의 속성 등 (Map 형태로 저장) 
  
    <img width="400" src="https://github.com/leeeha/Android-TIL/assets/68090939/8005a4fc-8504-46c1-bf2f-c52038969e59"/>
</div>
</details>

### 세션 인증 방식

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/ad89bec3-1271-4281-b372-11d614ee6621"/>

1. 유저가 웹사이트에서 로그인 하면, **서버는 메모리(혹은 디비)에 세션을 생성**하여 유저 정보를 저장한다. (이때 세션 식별을 위해 SESSION ID를 기준으로 저장) 
2. 서버가 클라이언트의 요청에 대한 응답값으로 **쿠키에 SESSION ID를 담아서** 보낸다. 
3. 브라우저는 서버에 요청을 보낼 때마다, 서버로부터 받은 **SESSION ID를 쿠키에 담아서 전송**한다. 
4. **서버는 클라이언트가 보낸 SESSION ID와 서버에 따로 관리하고 있는 SESSION ID를 비교하여 인증을 수행한다.** 

### 세션 인증 방식의 단점

- 쿠키를 포함한 요청이 외부에 노출되어도 세션 id 자체는 유의미한 개인 정보를 담고 있지 않다. 그러나 **해커가 세션 id를 탈취하여 클라이언트인 척 위장할 수 있다는 한계**가 있다.
- 서버는 별도의 세션 저장소가 필요하므로 요청이 많아지면 **서버 부하**가 심해진다.

## 토큰

<img width="500" src="https://github.com/leeeha/Android-TIL/assets/68090939/4f534e81-00ee-43cb-b794-7d4786fe7769">

1. 클라이언트가 서버에 로그인 요청을 보낸다.
2. 서버 측에서 클라이언트에게 인증되었다는 의미로 **유일한 ‘토큰’을 발급**한다. 
3. 클라이언트는 서버 측에서 보내준 토큰을 쿠키나 스토리지에 저장해두고, **서버에 요청을 보낼 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달**한다.
4. 서버는 클라이언트의 **토큰을 검증하고 요청에 응답**한다. 토큰에는 요청한 사람의 정보가 담겨있기 때문에 서버는 디비를 조회하지 않아도 누가 요청하는지 알 수 있다.

토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용된다. 왜냐하면 웹에는 쿠키와 세션이 있지만, 앱에는 없기 때문이다. 

### 서버(세션) 기반 vs. 토큰 기반 인증 시스템

**서버(세션) 기반 인증 시스템** 

- 서버에 저장된 ‘세션’으로 사용자 인증
- 서버 측에서 메모리, 로컬 파일, 디비에 사용자의 인증 정보를 따로 저장하여 관리
- **클라이언트의 상태를 서버에 계속 유지해놓고 사용 (Stateful)**
- 사용자가 증가함에 따라 성능 문제를 일으킬 수 있으며, 확장성이 낮다.

**토큰 기반 인증 시스템** 

- 세션 기반 인증 시스템의 단점 극복
- 인증 받은 사용자에게 ‘토큰’ 발급 → 클라이언트는 서버에 요청할 때마다 헤더에 토큰을 포함시켜서 전달 → 서버는 해당 토큰을 통해 인증 받은 사용자인지 검사
- **유저의 상태를 저장하고 있을 필요가 없으므로 Stateless**

### 토큰 인증 방식의 단점

- 쿠키, 세션과 다르게 토큰 자체의 길이가 길어서, 인증 요청이 많아질수록 **네트워크 부하**가 심해질 수 있다.
- Payload 자체는 암호화 되지 않기 때문에 **유저의 중요한 정보는 담을 수 없다.**
- **토큰을 탈취 당하면 대처하기 어렵다.** (따라서, 토큰의 ‘유효 기간’을 설정하여 사용)

# JWT이란

<img width="700" src="https://github.com/leeeha/Android-TIL/assets/68090939/ca528e64-723e-4400-b9e1-fc5d5ec4b51b"/>

JWT (JSON Web Token)이란 **인증에 필요한 정보들을 암호화 시킨 JSON 토큰**을 의미한다. 

JWT 기반 인증 방식은 **클라이언트가 JWT 토큰을 HTTP 헤더에 실어서 보내주면 서버가 이를 통해 유저를 식별하는 방식**이다. 

JWT은 JSON 데이터를 [Base64 URL-safe 인코딩](https://koonsland.tistory.com/57)을 통해 직렬화 한 것이며, 토큰 내부에는 **위변조 방지를 위해 서버의 개인키를 이용한 전자서명**도 들어있다. 

따라서, 사용자가 JWT을 서버로 전송하면 서버는 **서명(Signature)을 검증하는 과정**을 거치며, 검증이 완료되면 요청한 응답을 돌려준다.

## JWT 구조

<img width="700" src="https://github.com/leeeha/Android-TIL/assets/68090939/b79afd95-72a8-4bc4-8482-e717fab6215d"/>

### Header

<img width="232" alt="스크린샷 2024-07-03 오후 1 59 09" src="https://github.com/leeeha/Android-TIL/assets/68090939/6926ef2d-5ae5-4ee6-892f-44594cfe8b4c">

- alg: 서명에 사용되는 암호화 알고리즘의 종류
- typ: 토큰 타입

### Payload

<img width="280" alt="스크린샷 2024-07-03 오후 1 59 55" src="https://github.com/leeeha/Android-TIL/assets/68090939/8dbf0996-01e6-4a6d-b077-cad72d81e262">

서버, 클라이언트가 **실제로 사용할 정보의 조각들**인 Claim (key-value 형식으로 이루어진 한 쌍의 정보) 이 담겨있다.

- Registered Claim
    - 미리 정의된 클레임
    - iss (issuer: 발행자)
    - exp (expiration time: 만료 시간)
    - sub (subject: 제목)
    - iat (issued at: 발행 시간)
    - jti (jwt id)
- Public Claim
    - 사용자가 정의할 수 있는 클레임
    - 공개적인 정보 전달을 위해 사용
- Private Claim
    - 해당하는 당사자들 간에 정보 공유를 위해 만들어진 사용자 지정 클레임
    - 외부에 공개되어도 상관없지만, 해당하는 유저를 특정할 수 있는 정보를 담고 있음.

### Signature

<img width="400" src="https://github.com/leeeha/Android-TIL/assets/68090939/bfec76b2-8fa1-40f9-99d4-f5d809fb6091"/>

<img width="700" src="https://github.com/leeeha/Android-TIL/assets/68090939/b0794c53-1305-4b98-81e6-5d0c1f83b5d0"/>

- 헤더에 정의된 암호화 알고리즘 사용
- 헤더, 페이로드는 단순히 인코딩 된 값이므로 제 3자가 복호화 할 수 있지만, **시그니처는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화 할 수 없다. 따라서, 시그니처는 토큰의 위변조 여부를 확인하는 데 사용된다.**

## JWT 인증 방식

<img width="700" src="https://github.com/leeeha/Android-TIL/assets/68090939/cf7ddd8c-663e-4a71-92cf-10b1e188104f"/>

1. 사용자가 아이디, 패스워드를 갖고 서버에 로그인 요청을 보낸다. 
2. 서버는 클라이언트로부터 인증 요청을 받으면 헤더, 페이로드, 시그니처를 정의한다. 이를 기반으로 암호화 한 **JWT을 클라이언트에게 발급**해준다. 
3. 클라이언트는 서버로부터 받은 JWT을 로컬 스토리지에 저장하고 (웹의 경우, 쿠키에도 저장 가능) 서버에 요청을 보낼 때마다 **Authorization Header에 액세스 토큰을 담아서 보낸다.** 
4. 서버는 클라이언트가 Header에 담아서 보낸 JWT이 **서버에서 발행한 토큰과 일치하는지 확인하는 인증 과정**을 거친다. 인증이 통과되면 **페이로드에 들어있는 유저 정보를 조회**하여 클라이언트에게 보내준다. 
5. 클라이언트가 서버에 요청을 보냈는데, **액세스 토큰의 시간이 만료**되면 클라이언트는 리프레시 토큰을 이용하여 
6. 서버로부터 **새로운 액세스 토큰을 발급** 받는다. 

<br>

<details>
<summary>토큰 인증이 신뢰성을 갖는 이유</summary>
<div markdown="1">

서버는 토큰 안에 들어있는 정보가 무엇인지 아는 게 중요한 것이 아니라, **해당 토큰이 ‘유효한 토큰’인지 확인하는 것이 중요**하다. 
따라서 클라이언트로부터 받은 **JWT의 헤더, 페이로드를 서버의 key 값을 이용해 시그니처를 다시 만들고 이를 비교하며 일치했을 경우 인증을 통과**시킨다.

</div>
</details>

<br>

<details>
<summary>JWT은 서명(인증)이 목적이다.</summary>
<div markdown="1">

JWT은 Base64로 인코딩 하기 때문에 디버거를 사용하면 1초만에 복호화 할 수 있다. 복호화 하면 사용자의 데이터를 담은 페이로드 부분이 그대로 노출되기 때문에 여기에는 비밀번호 같은 민감한 정보는 넣지 말아야 한다. 
이를 통해 알 수 있는 것은, 토큰 인증 방식의 진짜 목적은 정보 보호가 아니라 **‘위조 방지’** 라는 것이다. 시그니처에 사용된 비밀키가 노출되지 않는 이상, **페이로드의 데이터를 위조해도 시그니처를 비교하는 인증 과정에서 바로 걸러지기 때문이다.**

</div>
</details>

## JWT 인증 방식의 장단점

### 장점

- 헤더, 페이로드를 갖고 시그니처를 생성하므로 **데이터 위변조를 막을 수 있다.**
- 인증 정보에 대한 **별도의 저장소가 필요없다.** 즉, 서버는 **Stateless**가 되어 확장성이 우수해질 수 있다.
- JWT은 토큰에 대한 기본 정보, 클라이언트에 전달할 정보, 토큰이 검증되었음을 증명하는 서명 등 **필요한 모든 정보를 자체적으로 지니고 있다.**
- 토큰 기반이므로 **다른 로그인 시스템에 접근 및 권한 공유가 가능하다**. (쿠키와의 차이점) OAuth의 경우 자체 로그인 없이도, 구글, 카카오 등 소셜 계정을 이용하여 다른 웹서비스에 로그인 할 수 있다.
- **모바일 어플리케이션 환경**에서도 잘 동작한다. (모바일은 세션 사용 불가)
- 서버는 **DB를 조회하지 않아도** 필요한 정보를 토큰에서 바로 얻을 수 있다.

### 단점

- **Self-Contained**: 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
- **토큰 길이**: 토큰의 페이로드에 3종류의 클레임을 저장하므로, 정보가 많아질수록 토큰 길이가 늘어나서 **네트워크 부하**가 생길 수 있다.
- **페이로드 탈취**: 페이로드 자체는 암호화 된 것이 아니라 Base64 인코딩 된 것이므로 중간에 페이로드를 탈취 당하면 디코딩으로 데이터를 볼 수 있기 때문에, 페이로드에 중요 데이터를 넣으면 안 된다.
- **토큰 탈취**: 서버가 Stateless 특징을 갖기 때문에, 토큰은 클라이언트 측에서 관리하고 저장한다. 따라서, 토큰 자체를 탈취 당하면 대처가 어렵다.

# JWT의 액세스 토큰, 리프레시 토큰

JWT도 제 3자에게 탈취 당할 가능성이 있기 때문에, 보통 현업에서는 이를 그대로 사용하지 않고 **액세스 토큰, 리프레시 토큰으로 나눠서 인증하는 방식**을 취한다. 

- **액세스 토큰**
    - 클라이언트가 갖고 있는 **실제 유저 정보가 담긴 토큰**
    - 클라이언트에서 요청을 보내면 서버에서 해당 토큰에 있는 정보를 활용하여 **사용자 정보에 맞게 응답 보냄.**
- **리프레시 토큰**
    - 짧은 수명을 가지는 액세스 토큰에게 **새로운 토큰을 발급해주기 위해 사용**되는 토큰
    - 보통 **DB에 유저 정보와 같이 기록**

정리하자면, **액세스 토큰은 유저 정보에 접근할 때 필요한 토큰, 리프레시 토큰은 액세스 토큰의 재발급에 관여하는 토큰**이라 말할 수 있다. (둘다 JWT에 해당) 

# 참고자료

[🌐 JWT 토큰 인증 이란? (쿠키 vs 세션 vs 토큰)](https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리)